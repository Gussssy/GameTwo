package com.gussssy.gametwo.game.pathfinding;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import com.gussssy.gametwo.game.GameManager;
import com.gussssy.gametwo.game.level.LevelTile;
import com.gussssy.gametwo.game.objects.npc.NPC;

public class AStarPathFinder {
	

	
	// All the current path nodes generated by a single pathfind attempt
	private ArrayList<PathNode> nodes = new ArrayList<PathNode>();
	
	// The new nodes created by the expansion of a node during a single pathfinding iteration
	private ArrayList<PathNode> newNodes = new ArrayList<PathNode>();
	
	// The node that is currently being evaluated
	private PathNode currentNode = null;
	
	

	
	
	// Variables that are set for each path find attempt
	
	// The target location
	private int targetX, targetY;
	
	// The start location
	private int startX, startY;
	
	
	private NPC npc;
	

	// booleans controlling termination or pathfinding
	boolean pathFound = false;
	boolean pathNotFound = false;
	
	
	// TESTING
	private int iterations = 0;
	int totalIterations = 0;
	int pathsFound = 0;
	int maxIterationsForSuccess = 0;
	int maxIterationsForFail = 0;
	int fails = 0;
	boolean lastSuccess = true;
	private ArrayList<FailedPathFind> failedPathFinds = new ArrayList<FailedPathFind>();
	
	// controls printing of debug information to the console
	boolean print = false;
		
	// controls printing detailed information regarding the success or failure statistics or all pathfinding attempts
	boolean printInfo = false;
	
	

	public Path findPath(GameManager gm, NPC npc, int startX, int startY, int targetX, int targetY){
		
		// setup stuff
		nodes.clear();
		currentNode = null;
		iterations = 0;
		pathFound = false;
		pathNotFound = false;
		gm.setAllTilesVisited(false);
		
		
		// FIX:  this should be set by constructor for this version of path finder
		PathFinderTwo.npc = npc;
		
		// Set target and start locations
		this.targetX = targetX; 
		this.targetY = targetY;
		this.startX = startX; 
		this.startY = startY;
		
		
		
		
		
		
		
		
		//////////////////////////////  Dealing with silly erroneous path finding attempts /////////////////////////
		
		
		// 1. Attempting to path to a solid tile 
		// 		(can only path to a non-solid tile that is directly above a solid tile.)
		//		
		// 	There is no way to path to a solid tile, path cannot be found. 
		if(gm.getLevelTileCollision(targetX, targetY)){
			
				System.out.println("PathFinderTwo ERROR: Cant path to a solid tile");
				System.out.println("Target Tile: x: " + targetX + ",  y: "  + targetY);
			
			return null;
		}
		
		
		
		// 2.  Attempting to path to a non-solid tile that is directly above another non-solid tile. 
		// 		(pathing to 'mid air' tiles: find the ground below and path to that.)
		//
		// Target tile will be shifted down until a solid tile is found. Will attempt to path to the tile above the solid tile. 
		
		
		// If the tile below the target tile is not solid: 
		if(!gm.getLevelTileCollision(targetX, targetY+1)){			
			
			
			// tile below the target tile was not solid, need to find a solid tile
			// start by looking 2 tiles below the target tile
			int tilesDown = 2;
			
			boolean foundGround = false;
			
			// keep going down until a solid tile is found. 
			while(!foundGround){
				
				// Check to see if the next tile down is solid:
				if(gm.getLevelTileCollision(targetX, targetY + tilesDown)){
					
					// found a solid tile below, path to targetY + tilesDown -1
					System.out.println("Have found a suitable tile to path too: target Y = " + (targetY + tilesDown -1));
					foundGround = true;
					
					// set new targetY
					targetY = targetY + tilesDown -1;
					
				}else{
					
					// tile was not soid, need to check further down
					tilesDown++;
				}	
			}
		}
		
		
		
		
		// 3. Pathing to the NPCs start location: 
		// 			Pathing to the NPCs current location creates a zero length path, which causes issues.
		//			- this shouldn't be possible but has occurred very infrequently
		if(startX == targetX && startY == targetY){
			System.out.println("Tried to path to start location. No pathfinding required");
			return null;
		}
		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		
		
		
		
		// Start PathFinding: 
		
		// Expand first node manually
		
		// get possible moves .... the tiles we can travel too
		nodes = getReachableNodes(gm, startX, startY, null);
				
		// increment iterations to 1
		iterations++;
				
		// mark the start tile/node as visited, it has been expanded.
		gm.getLevelTile(startX, startY).visited = true;
				
		// get the cost of moving to these tiles/nodes
		estimateCost(nodes, targetX, targetY, 0);
				
		// order by this cost 
		sortMovesByCost(nodes);
		
		
		
		
		// RECURSIVE PATHFINDING:  
		
		
		// While a path has not yet been found OR the path has not yet been determined impossible, continuing expanding the least cost node. 
		while(!pathFound && !pathNotFound){
			
			expandLeastCostNode(gm);

		}

	
		
		
		// EVALAUATING RESULTS FROM PATHFINDING: 
		

		if(pathFound){
			
			
		
			// Now generate a path for the NPC to execute
			ArrayList<PathNode> path = new ArrayList<PathNode>();
			
			
			// Read backwards through the PathNodes to find the path that was taken: 
			
			// Start by adding the last expanded node to the path, the final step in the path.
			path.add(currentNode);
			
			// Loop backwards through the Path nodes
			//		adding each node to the path
			//					continue until we find the start node (the PathNode with the previosNode field set to null)
			while(currentNode.previousNode != null){
				
				// Add the current nodes preceeding node to the path
				path.add(0, currentNode.previousNode);
				
				// Now set the current node to be the preccesding node to continue reading backwards
				currentNode = currentNode.previousNode;
			}
				
			
			
				return new Path(path, npc, gm);




		} else if(pathNotFound){
			
			

			return null;
			
			
		}
		
		// this shouldn't be reachable
		return null;
		
	}
	
	
	
	
	
	
	/**
	 * Expands the node with the lowest estimated cost, generating new nodes from adjacent accessible tiles.
	 * 
	 *  @param GameManager used in this context to access the level tiles
	 */
	public void expandLeastCostNode(GameManager gm){
		
	
		
		// FAIL CHECKING
		// if there are no more nodes left to expand, a path to the target tile cannot be found.
		if(nodes.size() == 0){
			
			pathNotFound = true;
			return;
		}
		
		
		// GET THE NEXT NODE TO EXPAND
		// Get the node at the start of the list, this is the least cost node
		currentNode = nodes.get(0);
		
		
		// CHECKING TO SEE IF TARGET HAS BEEN REACHED
		if((targetX == currentNode.endTileX) && (targetY == currentNode.endTileY)){
			
			pathFound = true;
			return;
		}
		
	
		// remove the expanded node from the 'queue' 
		nodes.remove(0);
		
		// increment iterations
		iterations++;
		
		// mark the end tile of this PathNode as visited
		gm.getLevelTile(currentNode.endTileX, currentNode.endTileY).visited = true;
		
		
		// Determine all possible nodes reachable from the current node
		ArrayList<PathNode> newNodes = getReachableNodes(gm, currentNode.endTileX, currentNode.endTileY, currentNode);
		
		
		// estimate the cost associated with the new nodes
		estimateCost(newNodes, targetX, targetY, currentNode.distanceFromStart);
		

		// add the new nodes to the queue
		for(PathNode pm : newNodes){
			nodes.add(pm);	
		}
		
		
		// sort nodes by descending estimated cost
		sortMovesByCost(nodes);
		
	}
	
	
	
	
	
	
	
	
	/**
	 *  Apply heuristic to newly generated PathNodes.  
	 *  
	 *  Heuristic function uses the Manhattan distance.
	 *  
	 *  
	 *  @param newNodes, the newly generated PathNodes
	 *  @param targetX, the x location of the target tile
	 *  @param targetY, the y location of the target tile
	 *  @param pathlength, the actual length of this path so far leading up to this node
	 **/
	public void estimateCost( ArrayList<PathNode> newNodes, int targetX, int targetY, int pathLength){
		
		
		for(PathNode node : newNodes ){
			
			
			// Get the actual distance/cost of the path to this node from the start
			
			// determine the cost of moving from the previous node to this node
			int costToThisNodeFromPreviousNode = Math.abs(node.startTileX - node.endTileX) + Math.abs(node.startTileY - node.endTileY);
			
			// add the above value to the current length of the path to give the actual cost to this node
			node.distanceFromStart = costToThisNodeFromPreviousNode + pathLength; 
			
		
			
			
			// Get the Estimated Cost to reach the Target from this node
			
			// Estimate cost to reach target using the Manhattan distance
			int xCost = Math.abs(node.startTileX - node.endTileX) + Math.abs(node.endTileX - targetX);
			int yCost = Math.abs(node.startTileY - node.endTileY) + Math.abs(node.endTileY - targetY);
			
			int estimatedCost = xCost + yCost;
			
			
			
			// Combine actual and estimated cost to get Total Cost
			node.totalCost = node.distanceFromStart + estimatedCost;
			
			
		}	
		
	}
	
	
	
	
	
	




	/**
	 *  Determines the possible moves that can be made by an NPC from the the current tile position. 
	 *   - a move is possible if collision with level tiles is not a problem
	 *   - the NPC can jump high enough
	 *   - the the tile position at the end of the movement has not already been visited
	 *   
	 *   Returns an arrayList containing the PossibleMoves.
	 **/
	public ArrayList<PathNode> getReachableNodes(GameManager gm, int tileX, int tileY, PathNode previousMove){

		ArrayList<PathNode> possibleNodes = new ArrayList<PathNode>();
		
		int endTileX;
		int endTileY;
		
		
		// PRETTY IFFY ABOUT THIS CASE ADDED HERE
			// Is it really the job of this method to be worried about what is visited. These tiles may get visited later. So I need to recheck visited before executing one of these steps.
		
		// what if the npc is not on a solid tile when initiating pathfinding..? is this ok? 
			// I probably shouldnt limit pathfinding to only on the ground but the npc will fall anyway..
		
		
		//  Is the NPC in the air right now? 
		
		if(!gm.getLevelTileCollision(tileX, tileY+1)){
			
			if(print)System.out.println("NPC in air must go DOWN");
			
			// npc is in the air
			
			// how far does the npc need to fall?
			// keep going down untill there is collision
			int tilesDown = 1;
			while(!gm.getLevelTileCollision(tileX, tileY + tilesDown)){
				tilesDown ++;
			}
			
			// remove tilesDown overshoot of 1
			tilesDown--;
			
			// in this case if below is visited is not important, for whatever reason, the npc is in the air aand has to fall
			// this will be the only possible move from this tile.
			possibleNodes.add(new PathNode(Movement.DOWN, tileX, tileY, tileX, tileY+tilesDown, tilesDown, previousMove));
			if(print)System.out.println("\t adding node");
			
			
			return possibleNodes;
			
		}
		
		
		
		
		// -	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
		// 											GOING RIGHT
		
		//Can we go right?
		if(!gm.getLevelTileCollision(tileX + 1, tileY)){
			
			// can go right
			if(print)System.out.println("RIGHT is possible");
			
			// but will npc fall?
			if(!gm.getLevelTileCollision(tileX + 1, tileY +1)){
				
				// yes NPC will fall.
				if(print)System.out.println("\t Right leads to a fall");
				
				// how much will NPC fall?
				// keep going down untill there is collision
				int tilesDown = 1;
				while(!gm.getLevelTileCollision(tileX + 1, tileY + tilesDown)){
					tilesDown ++;
				}
				
				// remove tilesDown overshoot of 1
				tilesDown--;
				
				if(print)System.out.println("\t Right leads to a fall of: " + tilesDown + " tiles");
				
				// Determine end tile location
				endTileX = tileX + 1;
				endTileY = tileY + tilesDown;
				
				// Has this location been visited already? 
				if(!gm.getLevelTile(endTileX, endTileY).visited){
					
					// ADD POSSIBLE MOVEMENT - RIGHT + DOWN 
					possibleNodes.add(new PathNode(Movement.RIGHT_DOWN, tileX, tileY, tileX+1, tileY+tilesDown, tilesDown, previousMove));
					if(print)System.out.println("\t adding node");
					
				}else if(print)System.out.println("\tCant go right + down. End tile was visited");
				
			}else{
				
				// No falling, just try move right.
				
				// Determine end tile location
				endTileX = tileX + 1;
				endTileY = tileY;
				
				// Has this location been visited already? 
				if(!gm.getLevelTile(endTileX, endTileY).visited){
					
					// ADD POSSIBLE MOVEMENT - RIGHT 
					possibleNodes.add(new PathNode(Movement.RIGHT, tileX, tileY, endTileX, endTileY, previousMove));
					if(print)System.out.println("\t adding node");
				
				}else if(print)System.out.println("\tCant go right. End tile was visited");
			}
		}
		
		
		
		
		// -	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	- //
		// 												GOING LEFT										  //
		
		//Can we go left?
			if(!gm.getLevelTileCollision(tileX - 1, tileY)){
					
				// can go left
				if(print)System.out.println("LEFT is possible");
				
				// but will npc fall?
				if(!gm.getLevelTileCollision(tileX - 1, tileY +1)){
					
					// yes NPC will fall.
					if(print)System.out.println("\t Left leads to a fall");
					
					// how much will NPC fall?
					
					// keep going down untill there is collision with a solid tile. 
					int tilesDown = 1;
					while(!gm.getLevelTileCollision(tileX - 1, tileY + tilesDown)){
						tilesDown ++;
					}
					
					// this will always overshoot by 1, so remove overshoot
					tilesDown--;
					
					if(print)System.out.println("Going left leads to a fall of: " + tilesDown + " tiles");
					
					// Determine end tile location
					endTileX = tileX - 1;
					endTileY = tileY + tilesDown;
					
					// Has this location been visited already? 
					if(!gm.getLevelTile(endTileX, endTileY).visited){
						
						// ADD POSSIBLE MOVEMENT - LEFT + DOWN
						//System.out.println("ADDING LEFT DOWN");
						possibleNodes.add(new PathNode(Movement.LEFT_DOWN, tileX, tileY, endTileX, endTileY, tilesDown, previousMove));
						if(print)System.out.println("\t adding node");
					
					}else if(print)System.out.println("\tCant go LEFT + DOWN. End Tile was visited");
					
				}else{
					
					// No falling, just try move left.
					
					// Determine end tile location
					endTileX = tileX - 1;
					endTileY = tileY;
					
					// Has this location been visited already? 
					if(!gm.getLevelTile(endTileX, endTileY).visited){
						
						// ADD POSSIBLE MOVEMENT - LEFT
						possibleNodes.add(new PathNode(Movement.LEFT, tileX, tileY, endTileX, endTileY, previousMove));
						if(print)System.out.println("\t adding node");
						
					}else if(print)System.out.println("\tCant go LEFT. End Tile was visited");
				}
		}



		// -	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	//
		// 												GOING UP ONCE									//
			
		// Can we go up? (above tile is not solid)
		if(!gm.getLevelTileCollision(tileX, tileY -1)){

			// UP ONE
			endTileY = tileY -1;

			// Up One is possible
			//System.out.println("UP ONE is possible");

			// Can we go right? (right hand below tile is sold, AND right hand above tile is not solid)
			if(gm.getLevelTileCollision(tileX + 1, tileY) && !gm.getLevelTileCollision(tileX + 1, tileY -1)){

				// UP ONE RIGHT ONE is possible
				if(print)System.out.println("UP ONE RIGHT ONE is possible");
				endTileX = tileX + 1;
				
				// Has this location been visited already? 
				if(!gm.getLevelTile(endTileX, endTileY).visited){
					
					// ADD POSSIBLE MOVEMENT - UP + RIGHT
					if(print)System.out.println("ADDING UP ONE RIGHT ONE");
					possibleNodes.add(new PathNode(Movement.UP_RIGHT, tileX, tileY, endTileX, endTileY, previousMove));
					if(print)System.out.println("\t adding node");
					
				} else if(print)System.out.println("Cant go UP + RIGHT. End Tile was visited");
				
				
				
			}


			// Can we go left? (left hand below tile is sold, AND left hand above tile is not solid)
			if(gm.getLevelTileCollision(tileX - 1, tileY) && !gm.getLevelTileCollision(tileX - 1, tileY -1)){

				// UP ONE LEFT ONE is possible
				if(print)System.out.println("UP ONE LEFT ONE is possible");
				endTileX = tileX - 1;
				
				// Has this location been visited already? 
				if(!gm.getLevelTile(endTileX, endTileY).visited){
					
					// ADD POSSIBLE MOVEMENT - UP + LEFT
					possibleNodes.add(new PathNode(Movement.UP_LEFT, tileX, tileY, endTileX, endTileY, previousMove));
					if(print)System.out.println("\t adding node");
					
				} else if(print)System.out.println("Cant go UP + LEFT. End Tile was visited");
			}


			
			
			// -	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-//
			//										 GOING UP TWICE											 //
			
			// Can we go up for a second time?
			if(!gm.getLevelTileCollision(tileX, tileY - 2)){

				// UP TWO
				endTileY = tileY -2;

				// Up Two is possible
				//System.out.println("UP TWO is possible");


				// Can we go right? (right hand below tile is sold, AND right hand above tile is not solid)
				if(gm.getLevelTileCollision(tileX + 1, tileY - 1) && !gm.getLevelTileCollision(tileX + 1, tileY -2)){

					// UP TWO RIGHT ONE is possible
					if(print)System.out.println("UP TWO RIGHT ONE is possible");
					endTileX = tileX + 1;
					
					// Has this location been visited already? 
					if(!gm.getLevelTile(endTileX, endTileY).visited){
						possibleNodes.add(new PathNode(Movement.UP_UP_RIGHT, tileX, tileY, endTileX, endTileY, previousMove));
						if(print)System.out.println("\t adding node");
					}else if(print)System.out.println("\t Can't do this, end tile visited.");
				}


				// Can we go left? (left hand below tile is sold, AND left hand above tile is not solid)
				if(gm.getLevelTileCollision(tileX - 1, tileY -1) && !gm.getLevelTileCollision(tileX - 1, tileY -2)){

					// UP TWO LEFT ONE is possible
					if(print)System.out.println("UP THREE LEFT ONE is possible");
					endTileX = tileX - 1;
					
					// Has this location been visited already? 
					if(!gm.getLevelTile(endTileX, endTileY).visited){
						possibleNodes.add(new PathNode(Movement.UP_UP_LEFT, tileX, tileY, endTileX, endTileY, previousMove));
						if(print)System.out.println("\t adding node");
					} else if(print)System.out.println("\t Can't do this, end tile visited.");
				}


				
				// 	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-//	
				// 											GOING UP THRICE											 //
				
				// Can we go up for a third and final time
				if(!gm.getLevelTileCollision(tileX, tileY - 3)){
					
					
					// UP THREE
					endTileY = tileY -3;
					//System.out.println("UP THREE is possible");
					
					
					// UP THREE RIGHT
					// Can we go right? (right hand below tile is sold, AND right hand above tile is not solid)
					if(gm.getLevelTileCollision(tileX + 1, tileY - 2) && !gm.getLevelTileCollision(tileX + 1, tileY -3)){

						// UP THREE RIGHT ONE is possible
						if(print)System.out.println("UP THREE RIGHT ONE is possible");
						endTileX = tileX + 1;
						
						// Has this location been visited already? 
						if(!gm.getLevelTile(endTileX, endTileY).visited){
							possibleNodes.add(new PathNode(Movement.UP_UP_UP_RIGHT, tileX, tileY, endTileX, endTileY, previousMove));
							if(print)System.out.println("\t adding node");
							
						}else if(print)System.out.println("\t Can't do this, end tile visited.");
					}


					// UP THREE LEFT
					// Can we go left? (left hand below tile is sold, AND left hand above tile is not solid)
					if(gm.getLevelTileCollision(tileX - 1, tileY - 2) && !gm.getLevelTileCollision(tileX - 1, tileY -3)){

						// UP THREE LEFT ONE is possible
						if(print)System.out.println("UP THREE LEFT ONE is possible");
						endTileX = tileX - 1;
						
						// Has this location been visited already? 
						if(!gm.getLevelTile(endTileX, endTileY).visited){
							possibleNodes.add(new PathNode(Movement.UP_UP_UP_LEFT, tileX, tileY, endTileX, endTileY, previousMove));
							if(print)System.out.println("\t adding node");
							
						} else if(print)System.out.println("\t Can't do this, end tile visited.");
					}		
				}
			}
		}

		
		
		
		
		
		return possibleNodes;

	}
	
	
	
	
	
	public static void sortMovesByCost(ArrayList<PathNode> possibleMoves){
		
		
		
				// Sort PathNodes in descending order by their total cost
				Collections.sort(possibleMoves, new Comparator<PathNode>(){

					@Override
					public int compare(PathNode pm0, PathNode pm1){

						if(pm0.totalCost > pm1.totalCost){
							return 1;
						}else{
							return -1;
						}
					}
				});
		
	}
	
	
	
	
	/**
	 * Used for testing. Initiates pathfinding so that expandLeastCostnode() can be called for a single iteration after this method has been executed.
	 * - sets everything up so each time expandLeastCostNodes is called, single node expansion occurs.
	 * - this is most useful when boolean GameManager.renderPathFinding is set to true;
	 **/
	public void initPathFinding(GameManager gm, int startX, int startY, int targetX, int targetY){
		
		// Setup PathFinder
		nodes.clear();	// ensure nodes is clear
		iterations = 0;	// reset iterations counter
		
		// Set the target
		PathFinderTwo.targetX = targetX; 
		PathFinderTwo.targetY = targetY;
		
		
		// Expand the first node:
		
		// get possible moves .... the tiles we can travel too
		nodes = getReachableNodes(gm, startX, startY, null);
		
		// increment interations to 1 as a the first node expansion has occured
		iterations++;
		
		// mark the start node as visited, it has been expanded.
		gm.getLevelTile(startX, startY).visited = true;
		
		// get the cost of moving to the identified nodes
		estimateCost(nodes, targetX, targetY, 0);
		
		// order nodes by thier cost 
		sortMovesByCost(nodes);
		
		// Everything is now in place to pathFind with expandleastCostNode()
		
		
		System.out.println("PathFinder Two ready to go !");

	}
	
	
	
	
	
	
	public void setPathMap(GameManager gm, int tileX, int tileY){
		
		nodes.clear();
		LevelTile temp;
		PathNode toExpand;
		
		nodes = getReachableNodes(gm, tileX, tileY, null);
		
		// mark end tile of all nodes as visited
		for(PathNode node : nodes){
			temp = gm.getLevelTile(node.endTileX, node.endTileY);
			if(temp == null){
				// tile is OOB, dont mark it
				
			}else {
				temp.visited = true;
				temp.accessible = true;
			}
		}
		
		while(!nodes.isEmpty()){
			
			toExpand = nodes.get(0);
			nodes.remove(0);
			
			newNodes.clear();
			newNodes = getReachableNodes(gm, toExpand.endTileX, toExpand.endTileY, null);
			
			
			// mark end tile of all nodes as visited
			for(PathNode node : newNodes){
				temp = gm.getLevelTile(node.endTileX, node.endTileY);
				if(temp == null){
					// tile is OOB, dont mark it
					
				}else {
					temp.visited = true;
					temp.accessible = true;
					nodes.add(node);
				}
			}
				
		}
		
	}
	
	
	/**
	 * Print infomation to the console regarding the success or failure of the last path find attempt
	 * 
	 *  @param success wether or not the current pathfindd attempt was successful or not. 
	 */
	private void printInfo(boolean success){
		
		
		if(success){
			totalIterations += iterations;
			pathsFound++;
			if(maxIterationsForSuccess < iterations)maxIterationsForSuccess = iterations;

			System.out.println("\n\n\n--> --> PATHFINDER INFO <-- <--");
			System.out.println("\n\t - - - Attempt Successful - - -");
			if(lastSuccess)
				System.out.println("\n\t - - - Last Attempt Successful - - -");
			else		System.out.println("\n\t! ! ! Last Attempt UNSUCCESSFUL ! ! !");
			System.out.println("\n\tAverage Iterations per attempt: " + (totalIterations/(fails + pathsFound)));
			System.out.println("\n\tMax interations on a successful pathFind: " + maxIterationsForSuccess);
			System.out.println("\n\tMax interations on a unsuccessful pathFind: " + maxIterationsForFail);
			System.out.println("\n\tPathsFound:\t\t" + pathsFound);
			System.out.println("\n\tFails:\t\t\t" + fails);
			System.out.println("--> --> --> <> <-- <-- <--\n\n\n");
			lastSuccess = true;
			
			System.out.println("\n Failed Path Finds: ");
			for(FailedPathFind f : failedPathFinds){
				System.out.println(f.toString());
				
			}
			
		}else{
			
			totalIterations += iterations;
			fails++;
			if(maxIterationsForFail < iterations)maxIterationsForFail = iterations;

			System.out.println("\n\n\n--> --> PATHFINDER INFO <-- <--");
			System.out.println("\n\t! ! ! Attempt UNSUCCESSFUL ! ! !");
			if(lastSuccess)
				System.out.println("\n\t - - - Last Attempt Successful - - -");
			else		System.out.println("\n\t! ! ! Last Attempt UNSUCCESSFUL ! ! !");
			System.out.println("\n\tAverage Iterations per attempt: " + (totalIterations/(fails + pathsFound)));
			System.out.println("\n\tMax interations on a successful pathFind: " + maxIterationsForSuccess);
			System.out.println("\n\tMax interations on a unsuccessful pathFind: " + maxIterationsForFail);
			System.out.println("\n\tPathsFound:\t\t" + pathsFound);
			System.out.println("\n\tFails:\t\t\t" + fails);
			System.out.println("--> --> --> <> <-- <-- <--\n\n\n");
			lastSuccess = false;
			
			System.out.println("\n Failed Path Finds: ");
			for(FailedPathFind f : failedPathFinds){
				System.out.println(f.toString());
				
			}
			
		}
		
	}


}
