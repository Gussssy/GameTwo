// determine are we stuck? 
		// stuck posisiton
		
		
		// if the target is within 50 pixels onm the x axis follow it
		if(Math.abs(target.getPosX()-posX) < 35){
			follow = true;
		}else{
			if(follow == true){
				follow = false;
				movingLeft = false; 
				movingRight = false;
			}
		}
		

		
		
		
		// If not following bot bot will idle
		if(!follow){
			
			actionTime--;
			
			// If not executing then need to get a new action to do
			if(actionTime < 0){
				movingLeft = false; 
				movingRight = false;
				action = random.nextInt(3);
				actionTime = random.nextInt(300);
				
				System.out.println("New Action: " + action + ", duration: " + actionTime + " frames");
				
				switch(action){
				case 0:
					// just wait, do nothing
				case 1:
					movingLeft = true;
					break;
				case 2:
					movingRight = true;
					break;
				default:
					System.out.println("Action not recognised");
				}	
			}			
		}
		
		
		if(stuckLeft || stuckRight){
			willJump = true;
		}

		
		// determine which direction to move to follow player, jump if stuck.
		if(follow){
			// is bot bot close enough to player? 
			if(Math.abs(target.getPosX()-posX) > 16){

				if(target.getPosX()-posX > 0){
					// target is further right
					movingRight = true;
					if(stuckRight)willJump = true;
				}else{
					movingLeft = true;
					if(stuckLeft)willJump = true;
				}


			} else {
				//botbot is close enough to player
				movingLeft = false; 
				movingRight = false;
			}
			
		}
		







// BOT BOT OLDS COLLISION DETECTION FOR PLATFORMS
/*
		System.out.println("\n\n\nCollision");
		
		for(Component c : components){
			System.out.println(c.getTag());
		}
		*/

		/*
		// Collision with platform
		if(other.getTag().equals("platform")){
			AABBComponent botbotAABB = (AABBComponent) this.findComponent("aabb");
			AABBComponent otherAABB = (AABBComponent) other.findComponent("aabb");

			// now we look at the last frame AABB positions of platform and player
			// How does using last frame change shit...
			// this just changes if we process a side or top/bot collision 
			if(Math.abs(botbotAABB.getLastCenterX() - otherAABB.getLastCenterX()) < botbotAABB.getHalfWidth() + otherAABB.getHalfWidth()){

				// Difference cX's is less than differences in cY's so colliding with top or bottom
				// TOP OR BOTTOM COLLISION
				//System.out.println("TOP OR BOTTOM COLLISION");


				// TOP COLLISION
				if(botbotAABB.getCenterY() < otherAABB.getCenterY()){
					int distance = (botbotAABB.getHalfHeight() + otherAABB.getHalfHeight()) - (otherAABB.getCenterY() - botbotAABB.getCenterY());
					offY -= distance;
					fallDistance = 0;

					// set new position for player and reset the player AABB to match new positon 
					setPosition();
					onAABB = true;
					//botbotOnThisPlatform = otherAABB;
					//playerAABB.updateAfterCollision();
				}

				// BOTTOM COLLISION
				if(botbotAABB.getCenterY() > otherAABB.getCenterY()){

					// flipped subtraction order when below platform, player cY is greater then platform cY
					int distance = (botbotAABB.getHalfHeight() + otherAABB.getHalfHeight()) - (botbotAABB.getCenterY() - otherAABB.getCenterY());
					offY += distance;
					// need to set fall distance to 0 or player will momentarily hover until fall distance peeks and becomes positive (positive = falling)
					fallDistance = 0;

					// set new position and update the players AABB
					setPosition();
					//playerAABB.updateAfterCollision();
				}


			}else{
				// SIDE COLLISION 
				//System.out.println("SIDE COLLISION");

				// LEFT COLLISION
				if(botbotAABB.getCenterX() < otherAABB.getCenterX()){
					int distance = (botbotAABB.getHalfWidth() + otherAABB.getHalfWidth()) - (otherAABB.getCenterX() - botbotAABB.getCenterX());
					System.out.println("Left Collision");
					offX -= distance;

					// set new position for player and reset the player AABB to match new positon 
					setPosition();
					//playerAABB.updateAfterCollision();
				}

				// RIGHT COLLISION
				if(botbotAABB.getCenterX() > otherAABB.getCenterX()){

					System.out.println("Right Collision");

					int distance = (botbotAABB.getHalfWidth() + otherAABB.getHalfWidth()) - (botbotAABB.getCenterX() - otherAABB.getCenterX());
					offX += distance;

					// set new position and update the players AABB
					setPosition();
					//playerAABB.updateAfterCollision();
				}

			}



		}*/
		
		
		Garbage useless too complicated movement code from path 
		// if current instruction is up, consider the next movement, if its also up then dont do anything, 
		//but if it is left or right, start moving right/left as soon as it makes sense too, 
		// Do we start moving left or right as soon as .. no wait till coming back down I think would have the best effect..
		// but what if bot bot wanted to jump over multiples anyway.. that could leave 
		if(instructions.get(progress) == "up"){
			
			// check to make sure we arent accesing out of bounds
			if(instructions.size() -1 >= progress + 1){
				
				// There is another instruction following the current up command
				
				System.out.println("There is at least one more step after the current..? ");
				System.out.println("Progress: " + progress);
				System.out.println("Index of last instruction: " + (instructions.size()-1));
				System.out.println("Will be accessing index: " + (progress + 1));
				nextInstruction = instructions.get(progress + 1);
				System.out.println("The next inmstruction following up is: " + nextInstruction);
				
				if(nextInstruction == "left"){
					
					// The next instruction is left. Will need to move left at some point
					if(!pather.isOnGround()){
						if(tileX >= nextTileX -1){
							// stop moving left
							return "stopLeft";
						}else{
							// nope keep going right
							return "left";	
						}
						
					}
					
				}else if(nextInstruction == "right"){
					
					// The next instruction is right. Will need to move right at some point
					if(!pather.isOnGround()){
						
						System.out.println("NPC has jumped and needs to move right");
						System.out.println("NPC tileX: " + tileX);
						
						// has npc moved right enough?
						if(tileX <= nextTileX +1){
							// moved enough right
							System.out.println("NPC has moved enough right ");
							progress++;
							progress++;
							setNextTile(progress);
							return "stopRight";
						}else{
							// nope keep going right
							return "right";	
						}
						
					}
				}
			}
		}
		
		
		
		// Print staements from UpdateMovement within the step completion block
		//System.out.println("XXX Current NPC tile location: tileX = " + npc.getTileX() + ", tileY = " + npc.getTileY());
		//System.out.println("XXX NPC will move to: tileX = " + nextX + ", tileY = " + nextY);
		//System.out.println("Current Instruction: " + currentMovement);
		//System.out.println("Next Instruction: " + moves.get(moveProg + 1));
		


// The old Tile Grenade collison code 
// process collisions
		// NOTE this only works in very specifc circumstances, will need to be completely reworked
		
		/**
		// collision on LEFT hand side: , if so need to invert the horizontal velocity
		if(tlc || blc) {
			
			if(vx < 0){
				System.out.println("Hit Left");
				vx = -vx * 0.8f;
			}
			
		}

		// collision on RIGHT hand side: , if so need to invert the horizontal velocity
		if(trc || brc){
			
			if(vx > 0){
				System.out.println("Hit Right");
				vx = -vx* 0.8f;
			}
			
		}

		// collision on TOP side: , if so need to invert the horizontal velocity
		if(tlc || trc){
			
			if(vy > 0){
				System.out.println("Hit Top");
				vy = -vy* 0.8f;
			}
			
		}

		// collision on BOTTOM hand side: , if so need to invert the horizontal velocity
		if(blc || brc){
			
			
			if(vy < 0){
				System.out.println("Hit Bottom");
				vy = -vy* 0.8f;
			}
		}
		
		// print empty line 
		System.out.println();
		*/




AABBCollisin with statioanry object - platform, new working code 15/11/20 but now moved to a seperate projectile collison class

if(true)return;
			
			AABBComponent platformHitbox = (AABBComponent) other.findComponent("aabb");
			float dy = hitBox.getCenterY() - hitBox.getLastCenterY();
			float dx = hitBox.getCenterX() - hitBox.getLastCenterX();
			GameManager.debugMessage3  = "dx: " + dx;
			GameManager.debugMessage4  = "dy: " + dy;
			
			
			// how much the object has penetrated top, bottom, left and right into the other objects hitbox 
			topDistance = hitBox.getStopY() - platformHitbox.getStartY();
			botDistance = platformHitbox.getStopY() - hitBox.getStartY();
			leftDistance = hitBox.getStopX() - platformHitbox.getStartX();
			rightDistance = platformHitbox.getStopX() -  hitBox.getStartX();
			
			GameManager.debugMessage5 = "TopDistance: " + topDistance;
			GameManager.debugMessage6 = "BotDistance: " + botDistance;
			GameManager.debugMessage7 = "LeftInc: " + leftDistance;
			GameManager.debugMessage8 = "RightInc: " + rightDistance;
			
			
			// what side hit the hhitbox first?
			
			// X AXIS
			if(dx != 0){
				// it could be left or right
				
				// if dx > 0, object is travelling right, could have impacted left side
				if(dx > 0){
						leftPossible = true;
						leftTime = Math.abs(leftDistance/dx);
						// 
					}else {
						rightPossible = true;
						rightTime = Math.abs(rightDistance/dx);
					}
				//  if dx < 0, object is travelling left, could have impacted right side
			}else {
				leftPossible = false;
				rightPossible = false;
			}
			
			// Y AXIS
			if(dy != 0){
				// it could be left or right
				
				// if dy > 0, object is travelling down, could have impacted top side
				if(dy > 0){
						topPossible = true;
						topTime = Math.abs(topDistance/dy);
						// 
					}else {
						botPossible = true;
						botTime =Math.abs(botDistance/dy);
					}
				//  if dy < 0, object is travelling up, could have impacted bottom side
			}else {
				topPossible = false;
				botPossible = false;
			}
			
			
			// PROCESSING
			
			// Single Axis Collision Processing
			// no movement on X Axis 
			if(dx == 0){
				
				if(topPossible){
					System.out.println("Top Collision");
					//resolution.y = (int)(posY - topDistance);	
					posY -= topDistance;
					vy = -vy;
				}
				
				if(botPossible){
					System.out.println("Bot Collision");
					//resolution.y = (int)(posY + botDistance);	
					posY += botDistance;
					vy = -vy;
				}
				
			// no movement on Y Axis
			} else if(dy == 0){

				if(leftPossible){
					System.out.println("Left Collision");
					//resolution.x = (int)(posX - leftDistance);	
					posX -= leftDistance;
					vx = -vx;
				}

				if(rightPossible){
					System.out.println("Right Collision");
					//resolution.x = (int)(posX + rightDistance);
					posX += rightDistance;
					vx = -vx;
				}

			
			// Movement on both Axis
			// Moving Right and Down:  could be left or top collision
			} else if(dx > 0 && dy > 0){
				
				if(leftTime < topTime){
					// left coll
					//resolution.x = (int)(posX - leftDistance);
					posX -= leftDistance;
					vx = -vx;
				}else {
					// top col
					//resolution.y = (int)(posY - topDistance);
					posY -= topDistance;
					vy = -vy;
				}
				
			// Moving Right and Up : could be left or bot collision
			}else if(dx > 0 && dy < 0 ){
				
				if(leftTime < botTime){
					// left coll
					//resolution.x = (int)(posX - leftDistance);
					posX -= leftDistance;
					vx = -vx;
				}else {
					// bot col
					//resolution.y = (int)(posY + botDistance);
					posY += botDistance;
					vy = -vy;
				}
				
			// Moving Left and Down: could be right or top collision
			}else if(dx < 0 && dy > 0){
				
				if(rightTime < topTime){
					// right coll
					//resolution.x = (int)(posX + rightDistance);
					posX += rightDistance;
					vx = -vx;
				}else {
					// top col
					//resolution.y = (int)(posY - topDistance);
					posY -= topDistance;
					vy = -vy;
				}
				
			
			// Moving Left and Up: could be right or bot collision	
			}else if(dx < 0 && dy < 0){
				
				if(rightTime < botTime){
					// right coll
					//resolution.x = (int)(posX + rightDistance);
					posX += rightDistance;
					vx = -vx;
				}else {
					// bot col
					//resolution.y = (int)(posY + botDistance);
					posY += botDistance;
					vy = -vy;
				}
				
			}
			
			
	
	
	
	
	BotBots old update code that was commented out 
	
	
	/**
	
		//////////////////////////////////////////////////////////////////////////////////////////
		//								Move Left and Right										//

		// move left
		if(gc.getInput().isKey(KeyEvent.VK_J) || movingLeft){

			if(gm.getLevelTileCollision(tileX - 1 , tileY) || gm.getLevelTileCollision(tileX - 1 , tileY + (int)Math.signum((int)offY)) ){

				// there is a solid block to the left

				// keep moving bot bot as collision may not have actually occured yet
				offX -= dt * speed;

				//Cannot get past solid tile on left hand side withput jumping
				//stuckLeft = true; //not using this anymore

				if(offX < -leftRightPadding) {
					
					// bot bot cannot move any further, he is now touching the left tile
					offX = -leftRightPadding;
				}
			} else {
				// no collision with left neighbouring tile 

				// bot bot is moving left
				offX -= dt * speed;
				//stuckLeft = false;	// cant be stuck if there is nothing solid to the left
			}
		}

		// move rigt
		if(gc.getInput().isKey(KeyEvent.VK_L) || movingRight){

			if(gm.getLevelTileCollision(tileX + 1 , tileY)|| gm.getLevelTileCollision(tileX + 1 , tileY + (int)Math.signum((int)offY))){

				// there is a solid tile to the right
				offX += dt * speed;

				// bot bot wont be able to move the the next tile without jumping
				//stuckRight = true;

				// If bot bot has moved into the tile: 
				if(offX > leftRightPadding){ 
					
					//botbot has moved to far right and is inside the right neighbouring tile,
					offX = leftRightPadding; // postions bot bot touching the right neighbouring tile
				}
			}else{
				
				// there is nothing solid to the right
				offX += dt * speed;
				//stuckRight = false;
			}
		}

		//////////////////////////////////////////////////////////////////////////////////////////
		// 									Jump and Gravity									//



		// Check if the player is on standing on AABB
		if(onAABB){
			
			// TODO:(26/8) pls comment this condition
			if(posX > (botbotOnThisPlatform.getParent().getPosX() - width - leftRightPadding) && posX < botbotOnThisPlatform.getParent().getPosX() + botbotOnThisPlatform.getParent().getWidth() - leftRightPadding){
				onGround = true;

				// BotBot is within x region, but is botbot y still on top of the platform?
				if((botbotOnThisPlatform.getParent().getPosY() - posY) > height + topPadding + 1){

					// BotBot is no longer ontop of the platform as it has moved down faster then the BotBot falls
					onGround = false;
					onAABB = false;
					botbotOnThisPlatform = null;
				} 

			} else {
				
				// BotBot is not within x range to be on the platform
				onAABB = false;
				botbotOnThisPlatform = null;
				onGround = false;
			}			
		}



		// Calculate the effect of gravity. Wont be applied till later
		fallDistance += dt * gravity;


		// JUMP only if on the ground
		if((gc.getInput().isKeyDown(KeyEvent.VK_I) || willJump) && onGround){
			System.out.println("\n\n\nBotBot jumps");
			willJump = false;
			fallDistance = jump;
			onGround = false;
			SoundManager.jump.play();
		}



		//Apply gravity/falling to botbot. Will always apply a little bit, but wont effect position untill sufficiently large
		offY += fallDistance;


		// Check for collisions above
		// if the absolute value off offX is greater then the padding, then get the signum of offX else get the signum of 0
		if(fallDistance < 0){
			if((gm.getLevelTileCollision(tileX, tileY - 1) || gm.getLevelTileCollision(tileX + (int)Math.signum((int)Math.abs(offX) > leftRightPadding ? offX : 0), tileY - 1)) && offY < -topPadding ){
				// Collision with above tile detected
				//System.out.println("Collision with above level tile, fall distance set to 0\n\n");
				fallDistance = 0;
				offY = -topPadding;	
				//System.out.println("Set botbot offY to:" + offY + " at collisions above");
			}
		}

		// Check for collision below 
		// Checks tile directly below and adjacent below tile if player is between two tiles
		if(fallDistance > 0){
			if((gm.getLevelTileCollision(tileX, tileY + 1) || gm.getLevelTileCollision(tileX + (int)Math.signum((int)Math.abs(offX) > leftRightPadding ? offX : 0), tileY + 1)) && offY >= 0 ){
				fallDistance = 0;
				//System.out.println("Set BotBot offY to 0");
				offY = 0;
				onGround = true;
			}else{
				onGround = false;
			}
		}






		//////////////////////////////////////////////////////////////////////////////////////////
		//							Tile Position Update										//

		// If botbot is more than half into neighbouring below tile....
		if(offY > GameManager.TS / 2){
			tileY++; //increment to the new tile
			offY -= GameManager.TS;
			//System.out.println("BotBot moved to lower tile, tileY: " + tileY);
		}

		// If botbot is more than half into neighbouring above tile....
		if(offY < -GameManager.TS / 2){
			tileY--; //decrement to the new tile
			offY += GameManager.TS;
			//System.out.println("BotBot moved to upper tile, tileY: " + tileY);
		}

		// If botbot is more than half into neighbouring right tile....
		if(offX > GameManager.TS / 2){
			tileX++; //increment to the new tile
			offX -= GameManager.TS;
			//System.out.println("BotBot moved to next right tile, tileX: " + tileX);
		}

		// If the botbot is more than half into neighbouring left tile...
		if(offX < -GameManager.TS / 2){
			tileX--; //decrement to the new tile
			offX += GameManager.TS;
			//System.out.println("BotBot moved to next left tile, tileX: " + tileX);
		}

		// Update botbot to new position
		posX = tileX * GameManager.TS + offX;
		posY = tileY * GameManager.TS + offY;
		

		//							End of Tile Position Update								//
		//////////////////////////////////////////////////////////////////////////////////////
*/		
			


The old LoadLevel Method from GameManager

/**
	 * Load Level Not used any more will remove soon. 22/11/20 
	 **/
	public void loadLevel(String path){

		Image levelImage = new Image(path);

		levelWidth = levelImage.getWidth();
		levelHeight = levelImage.getHeight();
		levelTiles = new LevelTile[levelWidth * levelHeight];

		// These are not correct, they are hex strings? Pixels aren't in this format.
		//int stone = 0xff808000;
		//int grass = 0xff00ff00;
		//int dirt = 0xffffffff;

		// Pixel int colour --> tile type
		int air = 0xffffffff;
		int grass = -16711936;
		int dirt = -16777216;
		int dirtNew = -8761812;
		int stone = -5592406;
		int brick = -8355840;
		int log = -12571632;

		for(int y = 0; y < levelHeight; y++){
			for(int x = 0; x < levelWidth; x++){

				int tileIndex = x + y * levelWidth;

				//System.out.println("x: " + x + ", y: " + y);
				//System.out.println("Pixel from level image contains: " + levelImage.getPixels()[tileIndex]);

				if(levelImage.getPixels()[tileIndex] != air ){

					if(levelImage.getPixels()[tileIndex] == dirt || levelImage.getPixels()[tileIndex] == dirtNew ){
						// This tile is to be a dirt block
						levelTiles[x + y * levelWidth] = new LevelTile(1, x, y);
						//System.out.println("Setting level tile at index: " + (x + y * levelWidth) + " as a DIRT BLOCK" );

					}else if (levelImage.getPixels()[tileIndex] == grass){
						// This tile is to be a grass block
						levelTiles[x + y * levelWidth] = new LevelTile(2, x, y);
						//System.out.println("Setting level tile at index: " + (x + y * levelWidth) + " as a GRASS BLOCK" );

					} else if(levelImage.getPixels()[tileIndex] ==  stone) {
						// This tile is to be a stone block
						levelTiles[x + y * levelWidth] = new LevelTile(3, x, y);
						//System.out.println("Setting level tile at index: " + (x + y * levelWidth) + " as a GRASS BLOCK" );

					}else if(levelImage.getPixels()[tileIndex] ==  brick){
						// brick
						levelTiles[x + y * levelWidth] = new LevelTile(4, x, y);

					}else if(levelImage.getPixels()[tileIndex] ==  log){
						// log
						levelTiles[x + y * levelWidth] = new LevelTile(5, x, y);

					}else{
						System.out.println("Unrecognised input pixel colour: " + levelImage.getPixels()[tileIndex]);
					}




				} else {
					// else false, level tile will be empty
					levelTiles[x + y * levelWidth] = new LevelTile(0,x,y);
					//System.out.println("Setting level tile at index: " + (x + y * levelWidth) + " as an AIR BLOCK" );
				}

			}
		}

	}
	
	Old level Loading from GameManager constructor
	// OLD LEVEL LOADING
		//loadLevel("/npc_movement_test_level_2.png");
		//loadLevel("/npc_movement_test_level_1.png");
		//player.setTileX(3);
		//player.setTileY(3);
		//loadLevel("/Arena2.png");
		//loadLevel("/Arena3.png");
		//loadLevel("/level3.png");
		//loadLevel("/level3.png");
		//loadLevel("/Arena5.png");
		//loadLevel("/Arena5_v2.png");
		// SPAWNERS
		// > Arena 3 spawners
		//objects.add(new NPCSpawner(2,22, "botbot"));
		//objects.add(new NPCSpawner(65,18, "badbotbot"));
		// Arena 3 addidtional spawners
		//objects.add(new NPCSpawner(23,8, "botbot"));
		//objects.add(new NPCSpawner(50,12, "badbotbot"));
		// > Arena2.png spawners
		//objects.add(new NPCSpawner(1,11, "botbot"));
		//objects.add(new NPCSpawner(33,11, "badbotbot"));
		//objects.add(new NPCSpawner(17,12, "goose"));
		// Arena5 Spawners
		//objects.add(new NPCSpawner(1,50, "botbot"));
		//objects.add(new NPCSpawner(151,53, "badbotbot"));
		//objects.add(new NPCSpawner(85,34, "goose"));
		//objects.add(new NPCSpawner(52,27, "smartbot"));
		// movement test 1 goose spawener
		//objects.add(new NPCSpawner(5,12, "goose"));

		// set path map
		// arena 5
		//PathFinder.setPathMap(this, 1, 50);
		//PathFinderTwo.setPathMap(this, 1, 50);
		//goose cage, arena 5
		//PathFinderTwo.setPathMap(this, 85, 35);
		// arena 2
		//PathFinder.setPathMap(this, 1, 11);			// NPC movement 1
	
	
	Old code to test pathfinding with old algoritm. Sets botbots target location
	
	// TESTING THE OLD PATHFINDING ALGORITM
		if(gc.getInput().isKeyDown(KeyEvent.VK_Q)){

			// set all tiles to not accessible and not visited for pathfinding.
			for(LevelTile tile : gm.getLevelTiles()){
				tile.accessible = false;
				tile.visited = false;
			}

			// Left click to set target location
			if(gc.getInput().isButton(1)){
				gm.getLevelTile(gc.getInput().getMouseX()/GameManager.TS,gc.getInput().getMouseY()/GameManager.TS ).checked = true;
				System.out.println("CLICKED");
			}

			// Convert mouse coords to game coords.
			//System.out.println("MouseX: " + gc.getInput().getMouseX());
			//System.out.println("MouseY: " + gc.getInput().getMouseY());
			int x = gc.getInput().getMouseX() + gc.getRenderer().getCamX();
			int y = gc.getInput().getMouseY() + gc.getRenderer().getCamY();
			//System.out.println("This translates to: x =  " + x + ", y = " + y);
			//System.out.println("Setting Botbots target location too: tilex = " + x/16 + ", tileY = " + y/16);

			// set this as botbot target location
			gm.botbot.setTargetLocation(x/16, y/16 );

		}
	
	
	
	Grenade Collison - before it was moved to seperate class
	//colliding = true;
			if(print)System.out.println("AABB Collison with tile");

			//AABBComponent platformHitbox = (AABBComponent) other.findComponent("aabb");
			float dy = hitBox.getCenterY() - hitBox.getLastCenterY();
			float dx = hitBox.getCenterX() - hitBox.getLastCenterX();
			DebugPanel.message3  = "dx: " + dx;
			DebugPanel.message4  = "dy: " + dy;


			// how much the object has penetrated top, bottom, left and right into the other objects hitbox 
			topDistance = hitBox.getStopY() - otherHitBox.getStartY();
			botDistance = otherHitBox.getStopY() - hitBox.getStartY();
			leftDistance = hitBox.getStopX() - otherHitBox.getStartX();
			rightDistance = otherHitBox.getStopX() -  hitBox.getStartX();

			DebugPanel.message5 = "TopDistance: " + topDistance;
			DebugPanel.message6 = "BotDistance: " + botDistance;
			DebugPanel.message7 = "LeftInc: " + leftDistance;
			DebugPanel.message8 = "RightInc: " + rightDistance;


			// what side hit the hhitbox first?

			// X AXIS
			if(dx != 0){
				// it could be left or right

				// if dx > 0, object is travelling right, could have impacted left side
				if(dx > 0){
					leftPossible = true;
					leftTime = Math.abs(leftDistance/dx);
					// 
				}else {
					rightPossible = true;
					rightTime = Math.abs(rightDistance/dx);
				}
				//  if dx < 0, object is travelling left, could have impacted right side
			}else {
				leftPossible = false;
				rightPossible = false;
			}

			// Y AXIS
			if(dy != 0){
				// it could be left or right

				// if dy > 0, object is travelling down, could have impacted top side
				if(dy > 0){
					topPossible = true;
					topTime = Math.abs(topDistance/dy);
					// 
				}else {
					botPossible = true;
					botTime =Math.abs(botDistance/dy);
				}
				//  if dy < 0, object is travelling up, could have impacted bottom side
			}else {
				topPossible = false;
				botPossible = false;
			}


			// PROCESSING

			// Single Axis Collision Processing
			// no movement on X Axis 
			if(dx == 0){

				if(topPossible){
					if(print)System.out.println("Top Collision");
					//resolution.y = (int)(posY - topDistance);	
					posY -= topDistance;
					vy = -vy;
				}

				if(botPossible){
					if(print)System.out.println("Bot Collision");
					//resolution.y = (int)(posY + botDistance);	
					posY += botDistance;
					vy = -vy;
				}

				// no movement on Y Axis
			} else if(dy == 0){

				if(leftPossible){
					if(print)System.out.println("Left Collision");
					//resolution.x = (int)(posX - leftDistance);	
					posX -= leftDistance;
					vx = -vx;
				}

				if(rightPossible){
					if(print)System.out.println("Right Collision");
					//resolution.x = (int)(posX + rightDistance);
					posX += rightDistance;
					vx = -vx;
				}


				// Movement on both Axis
				// Moving Right and Down:  could be left or top collision
			} else if(dx > 0 && dy > 0){

				if(leftTime < topTime){
					// left coll
					//resolution.x = (int)(posX - leftDistance);
					posX -= leftDistance;
					vx = -vx;
				}else {
					// top col
					//resolution.y = (int)(posY - topDistance);
					posY -= topDistance;
					vy = -vy;
				}

				// Moving Right and Up : could be left or bot collision
			}else if(dx > 0 && dy < 0 ){

				if(leftTime < botTime){
					// left coll
					//resolution.x = (int)(posX - leftDistance);
					posX -= leftDistance;
					vx = -vx;
				}else {
					// bot col
					//resolution.y = (int)(posY + botDistance);
					posY += botDistance;
					vy = -vy;
				}

				// Moving Left and Down: could be right or top collision
			}else if(dx < 0 && dy > 0){

				if(rightTime < topTime){
					// right coll
					//resolution.x = (int)(posX + rightDistance);
					posX += rightDistance;
					vx = -vx;
				}else {
					// top col
					//resolution.y = (int)(posY - topDistance);
					posY -= topDistance;
					vy = -vy;
				}


				// Moving Left and Up: could be right or bot collision	
			}else if(dx < 0 && dy < 0){

				if(rightTime < botTime){
					// right coll
					//resolution.x = (int)(posX + rightDistance);
					posX += rightDistance;
					vx = -vx;
				}else {
					// bot col
					//resolution.y = (int)(posY + botDistance);
					posY += botDistance;
					vy = -vy;
				}

			}

	
	

